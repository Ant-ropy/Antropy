import React, { useEffect, useMemo, useRef, useState } from "react";

// UI: shadcn/ui (available in this environment)
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Label } from "@/components/ui/label";
import { Slider } from "@/components/ui/slider";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { Download, Coins, ShieldCheck, Info, RefreshCw } from "lucide-react";

/**
 * Provably-fair coin flip demo that consumes your OWN binary sequence.
 * 
 * Key ideas:
 * - Uses your bitstream as the *only* randomness source.
 * - Applies a streaming Von Neumann extractor (pairs: 01=Heads, 10=Tails, 00/11 discarded)
 *   to neutralise bias while preserving unpredictability from your source.
 * - Shows a commitment (SHA-256) to the original bitstream at load; you can later reveal the
 *   exact bitstream to prove no tampering ("commit-reveal").
 * - Records an audit log (JSON) you can download.
 * - This is a demo UI (no real money); you must add server-side checks and compliance before use.
 */

// Utility: SHA-256 in browser
async function sha256Hex(str) {
  const enc = new TextEncoder();
  const buf = await crypto.subtle.digest("SHA-256", enc.encode(str));
  const bytes = new Uint8Array(buf);
  return [...bytes].map((b) => b.toString(16).padStart(2, "0")).join("");
}

// Consume a Von Neumann-valid outcome from a bitstream starting at index
function nextVNOutcome(bits, startIdx) {
  let i = startIdx;
  const n = bits.length;
  while (i + 1 < n) {
    const a = bits[i];
    const b = bits[i + 1];
    if (a !== b) {
      // 01 => Heads, 10 => Tails
      const outcome = a === "0" && b === "1" ? "HEADS" : "TAILS";
      return { outcome, nextIndex: i + 2, consumed: bits.slice(startIdx, i + 2) };
    }
    i += 2; // discard 00 or 11
  }
  return { outcome: null, nextIndex: n, consumed: bits.slice(startIdx, n) };
}

function formatPounds(v) {
  return new Intl.NumberFormat(undefined, { style: "currency", currency: "GBP" }).format(v);
}

export default function ProvablyFairCoinFlip() {
  // Provide your raw bitstream here (string of '0' and '1').
  // Replace this placeholder with your actual sequence or fetch it from your server.
  const [bitstream, setBitstream] = useState(
    "0101100110101011001101010110100101100110011010101001100110101011" // placeholder
  );

  const [index, setIndex] = useState(0); // cursor into raw bitstream
  const [balance, setBalance] = useState(100); // demo credits
  const [wager, setWager] = useState(5);
  const [pick, setPick] = useState("HEADS");
  const [commitment, setCommitment] = useState("");

  const [audit, setAudit] = useState([]);
  const [busy, setBusy] = useState(false);

  const remainingPairs = useMemo(() => Math.floor((bitstream.length - index) / 2), [bitstream, index]);

  useEffect(() => {
    // compute commitment once for current bitstream
    (async () => setCommitment(await sha256Hex(bitstream)))();
  }, [bitstream]);

  const canFlip = remainingPairs > 0 && wager > 0 && balance >= wager && !busy;

  async function doFlip() {
    setBusy(true);
    try {
      const { outcome, nextIndex, consumed } = nextVNOutcome(bitstream, index);
      if (!outcome) {
        alert("Not enough usable bits remain after Von Neumann extraction. Please load a longer sequence.");
        return;
      }

      const win = outcome === pick;
      const newBalance = win ? balance + wager : balance - wager;

      const entry = {
        ts: new Date().toISOString(),
        indexBefore: index,
        indexAfter: nextIndex,
        consumedBits: consumed,
        outcome,
        playerPick: pick,
        wager,
        result: win ? "+" + wager : "-" + wager,
        balanceAfter: newBalance,
      };
      setAudit((prev) => [entry, ...prev]);

      setIndex(nextIndex);
      setBalance(newBalance);
    } finally {
      setBusy(false);
    }
  }

  function resetDemo() {
    setIndex(0);
    setBalance(100);
    setAudit([]);
  }

  async function downloadAudit() {
    const payload = {
      committedHash: commitment,
      bitLength: bitstream.length,
      extraction: "Von Neumann (pairs; 01=H, 10=T)",
      audit: audit.slice().reverse(), // chronological
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "coinflip_audit.json";
    a.click();
    URL.revokeObjectURL(url);
  }

  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-50 to-slate-100 p-6">
      <div className="max-w-5xl mx-auto grid gap-6 lg:grid-cols-3">
        {/* Left column: Game */}
        <Card className="lg:col-span-2 shadow-lg rounded-2xl">
          <CardContent className="p-6">
            <div className="flex items-center justify-between mb-4">
              <h1 className="text-2xl font-semibold tracking-tight flex items-center gap-2">
                <Coins className="h-6 w-6" /> Provably-Fair Coin Flip
              </h1>
              <Badge variant="outline" className="font-mono">SHA-256(commit) ready</Badge>
            </div>

            <div className="grid md:grid-cols-2 gap-6">
              {/* Controls */}
              <div className="space-y-4">
                <div>
                  <Label className="mb-1 block">Your pick</Label>
                  <Tabs value={pick} onValueChange={setPick} className="w-full">
                    <TabsList className="grid w-full grid-cols-2">
                      <TabsTrigger value="HEADS">Heads</TabsTrigger>
                      <TabsTrigger value="TAILS">Tails</TabsTrigger>
                    </TabsList>
                  </Tabs>
                </div>

                <div>
                  <div className="flex items-center justify-between">
                    <Label>Wager</Label>
                    <span className="text-sm text-slate-500">{formatPounds(wager)}</span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Slider
                      value={[wager]}
                      onValueChange={(v) => setWager(v[0])}
                      min={1}
                      max={Math.min(50, balance)}
                      step={1}
                      className="mt-2"
                    />
                    <Input
                      type="number"
                      min={1}
                      max={balance}
                      value={wager}
                      onChange={(e) => setWager(Math.max(1, Math.min(balance, Number(e.target.value))))}
                      className="w-24"
                    />
                  </div>
                </div>

                <div className="flex items-center gap-3">
                  <Button onClick={doFlip} disabled={!canFlip}>
                    Flip {busy ? "…" : "coin"}
                  </Button>
                  <Button variant="secondary" onClick={resetDemo}>
                    <RefreshCw className="h-4 w-4 mr-1" /> Reset demo
                  </Button>
                </div>

                <div className="text-sm text-slate-600 space-y-1">
                  <div>Balance: <span className="font-semibold">{formatPounds(balance)}</span></div>
                  <div>Usable pairs remaining: <span className="font-mono">{remainingPairs}</span></div>
                  <div>
                    Commitment (SHA-256 of full bitstream):
                    <div className="font-mono text-xs break-all bg-slate-100 p-2 rounded mt-1">{commitment}</div>
                  </div>
                </div>
              </div>

              {/* Outcome & History */}
              <div className="space-y-4">
                <Card className="border-dashed">
                  <CardContent className="p-4">
                    <div className="text-sm text-slate-500 flex items-center gap-2 mb-2"><ShieldCheck className="h-4 w-4"/>Provability</div>
                    <p className="text-sm text-slate-700 leading-relaxed">
                      Each flip consumes bits from your committed sequence using a Von Neumann extractor. Download the audit log to verify indices, consumed bits, and outcomes. Later, reveal the full bitstream to anyone and they can recompute every flip.
                    </p>
                  </CardContent>
                </Card>

                <Separator />

                <div>
                  <div className="flex items-center justify-between mb-2">
                    <h2 className="text-lg font-medium">Recent flips</h2>
                    <Button variant="outline" size="sm" onClick={downloadAudit}>
                      <Download className="h-4 w-4 mr-1"/> Audit JSON
                    </Button>
                  </div>
                  <ScrollArea className="h-64 rounded border">
                    <table className="w-full text-sm">
                      <thead className="sticky top-0 bg-white z-10">
                        <tr className="text-left border-b">
                          <th className="px-3 py-2">Time</th>
                          <th className="px-3 py-2">Idx</th>
                          <th className="px-3 py-2">Bits</th>
                          <th className="px-3 py-2">Pick</th>
                          <th className="px-3 py-2">Outcome</th>
                          <th className="px-3 py-2">Δ</th>
                          <th className="px-3 py-2">Balance</th>
                        </tr>
                      </thead>
                      <tbody>
                        {audit.map((a, i) => (
                          <tr key={i} className="border-b font-mono">
                            <td className="px-3 py-2 whitespace-nowrap">{new Date(a.ts).toLocaleTimeString()}</td>
                            <td className="px-3 py-2">{a.indexBefore}→{a.indexAfter}</td>
                            <td className="px-3 py-2 break-all text-xs">{a.consumedBits}</td>
                            <td className="px-3 py-2">{a.playerPick[0]}</td>
                            <td className="px-3 py-2 font-semibold">{a.outcome}</td>
                            <td className={`px-3 py-2 ${a.result.startsWith("+") ? "text-green-600" : "text-red-600"}`}>{a.result}</td>
                            <td className="px-3 py-2">{formatPounds(a.balanceAfter)}</td>
                          </tr>
                        ))}
                        {audit.length === 0 && (
                          <tr>
                            <td className="px-3 py-6 text-center text-slate-500" colSpan={7}>No flips yet</td>
                          </tr>
                        )}
                      </tbody>
                    </table>
                  </ScrollArea>
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Right column: Bitstream & settings */}
        <Card className="shadow-lg rounded-2xl">
          <CardContent className="p-6 space-y-4">
            <div className="flex items-center gap-2 text-slate-700"><Info className="h-5 w-5"/> Bitstream</div>
            <Label htmlFor="bits" className="text-sm">Paste your raw bitstream (0/1 only)</Label>
            <textarea
              id="bits"
              value={bitstream}
              onChange={(e) => {
                const sanitized = e.target.value.replace(/[^01]/g, "");
                setBitstream(sanitized);
                setIndex(0);
                setAudit([]);
              }}
              className="w-full h-40 font-mono text-xs p-3 rounded border bg-white"
              placeholder="e.g., 0100110101..."
            />
            <div className="text-xs text-slate-500">Length: <span className="font-mono">{bitstream.length}</span> bits</div>

            <Separator />

            <div className="text-xs text-slate-600 leading-relaxed">
              <p className="mb-2"><strong>How this stays fair:</strong> We commit to the full bitstream hash before gameplay and consume bits in order using a bias-neutral extractor. Anyone can later verify outcomes by recomputing from the revealed sequence.</p>
              <ul className="list-disc pl-5 space-y-1">
                <li>Each flip uses 2+ raw bits; some pairs are discarded (00/11) to remove bias.</li>
                <li>When pairs run out, you must load more bits (fresh entropy).</li>
                <li>Server-side enforcement is required for real stakes; this demo is client-only.</li>
              </ul>
            </div>
          </CardContent>
        </Card>
      </div>

      <div className="max-w-5xl mx-auto mt-6 text-xs text-slate-500">
        <p>
          <strong>Compliance note:</strong> If used for real-money wagering, you must add age gating, limits, self-exclusion, AML/KYC, dispute processes, and jurisdiction-specific licensing. Consider running the extractor and indexing on the server and signing each round.
        </p>
      </div>
    </div>
  );
}
